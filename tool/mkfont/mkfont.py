"""
A primitive tool for embeding BMFont fonts into C programs.

Designed to be used during build of this project,
does not feature many safeguards, so it will throw exceptions
if something goes wrong.

Usage:
    mkfont.py <Font .zip file> \\
              <output .h> <output .c> \\
              <include path for .h from .c>

    It expects what there is a single .txt file in given
    archive, and it is BMFont font defenition. Atlas is
    expected to have same name as that file, but with .png
    instead of .txt

TODO:
    Rewrite this thing later, or just use Freetype/stb_truetype
    instead of all this embedding.

"""

import PIL.Image as Image
import zipfile
import sys
import shlex

# Names for static functions/variables in C file

INDEXER_NAME = 'index_for_glyph' # Function to get glyph index of codepoint
GLYPHS_NAME  = 'glyphs'          # Array of glyph data for each glyph image
ATLAS_NAME   = 'atlas'           # Atlas with all the glyphs packed

# -- Code generator itself

def gen_defenitions(header_file, source_file, props_file, image_file, include_path):
    """
    Generates .c and .h file.

    Params
    ------
    source_file : file
        Opened .c file

    header_file : file
        Opened .h file

    props_file : file
        Opened font defenition file

    image_file : file
        Opened atlas texture file, will be used by Pillow

    include_path : str
        Path to write in `#include` in .c file to include .h file
    """

    # -- Find some metadata
    common = None
    info = None

    for line_bytes in props_file.readlines():

        name, props = parse_line(line_bytes.decode())
        
        if name == 'common':
            if common is None:
                common = props
            else:
                raise ValueError('Multiple `common` tags in font file')
        elif name == 'info':
            if info is None:
                info = props
            else:
                raise ValueError('Multiple `info` tags in font')


    if common is None:
        raise ValueError('No `common` tags in input file')
    if info is None:
        raise ValueError('No `info` tags in input file')
    
    props_file.seek(0) # Reset the file after

    # Name for the exported variable
    var_name = 'glcvs_embeded_font_' + info['face'].replace(' ', '_') + '_' + info['size']

    # -- Generate header

    gen_header(header_file, info, var_name)

    # -- Generate source file

    source_file.write(f'#include "{include_path}"\n')
    source_file.write(f'\n')
    gen_atlas(source_file, image_file)
    gen_cmap(source_file, props_file)
    gen_font_def(source_file, common, var_name)


def gen_header(header_file, font_info, var_name):
    """
    Generate header file contents for this embeded font

    Params
    ------

    header_file : file
        File to write header contents into. Must have a `write()` method.

    font_info : dict
        Props of `info` tag from font defenition.

    var_name : str
        Name of exported variable, containing the font

    """

    header_file.write(f'/**\n')
    header_file.write(f' * \\file\n')
    header_file.write(f' * \\brief Embeded font `{font_info['face']}`'
                      f' of size `{font_info['size']}` \n')
    header_file.write(f' * \\note This file is automatically generated by `tool/mkfont`\n')
    header_file.write(f' */\n')
    header_file.write(f'\n')

    # Macro guard macro name
    guard_name = 'GLCVS_EMBEDED_FONT_' + font_info['face'].replace(' ', '_').upper() + font_info['size']

    header_file.write(f'#ifndef {guard_name}\n')
    header_file.write(f'#define {guard_name}\n')
    header_file.write(f'\n')
    header_file.write(f'#include "glcvs/font.h"\n')
    header_file.write(f'\n')
    header_file.write(f'/// Embeded {font_info['face']} font\n')
    header_file.write(f'const glcvs_embeded_font {var_name}();\n')
    header_file.write(f'\n')
    header_file.write(f'#endif // {guard_name}\n')


def gen_font_def(source_file, common, var_name):
    """
    Generate exported font defenition
    """

    source_file.write(f'const glcvs_embeded_font {var_name}() {{\n')
    source_file.write(f'  const glcvs_embeded_font ret = {{\n') #}}
    source_file.write(f'    .line_height = {common['lineHeight']},\n')
    source_file.write(f'    .above_baseline = {common['base']},\n')
    source_file.write(f'    .index_for_glyph = &{INDEXER_NAME},\n')
    source_file.write(f'    .glyphs = {GLYPHS_NAME},\n')
    source_file.write(f'    .atlas = &{ATLAS_NAME},\n')
    source_file.write(f'  }};\n')
    source_file.write(f'  return ret;\n');
    source_file.write(f'}}\n')
    source_file.write(f'\n')

def gen_cmap(
        source_file,
        props_file,
        notdef : str = '?'):
    chars = []

    notdef_char_index = None

    # -- Parse cmap defenition

    for idx, line_bytes in enumerate(props_file.readlines()):
        
        # Lines here look like `char id=... x=... ...`

        name, props = parse_line(line_bytes.decode())

        if name != 'char':
            continue

        chars.append(props)

    
    props_file.seek(0)

    chars.sort(key = lambda v : int(v['id']))
   
    notdef_char_index = ([ idx for idx, i in enumerate(chars) if int(i['id']) == ord(notdef)] + [None])[0]

    if notdef_char_index is None:
        raise ValueError('Character to print for missing glyphs not found in cmap')


    # -- Generate glyph table

    source_file.write(f'static const glcvs_embeded_glyph_data {GLYPHS_NAME}[] = {{\n') #}

    for idx, i in enumerate(chars):
        source_file.write(f'  /* [{idx:>4}] = */ ')
        source_file.write(f'{{ .tex_x = {i['x']:>4}, .tex_y = {i['y']:>4}, '
                         f'.tex_w = {i['width']:>2}, .tex_h = {i['height']:>2}, '
                         f'.x_off = {i['xoffset']:>2}, .y_off = {i['yoffset']:>2}, '
                         f'.advance = {i['xadvance']:>2} }},')
        source_file.write(f' // {repr(chr(int(i['id'])))} (U+{hex(int(i['id']))[2:]})\n')

    source_file.write(f'}};\n')
    source_file.write('\n')

    # -- Generate lookup function

    # Split cmap into segments
    segments = []
    for i in chars:
        id = int(i['id'])
        if len(segments) == 0 or segments[-1][1] != id - 1:
            # Sequence broken
            segments.append([id, id])
        else:
            segments[-1][1] = id

    offset = 0

    source_file.write('/// This function gets glyph index in the array above\n')
    source_file.write('/// for given codepoint\n')
    source_file.write(f'static unsigned {INDEXER_NAME} (unsigned codepoint) {{\n') #}
    
    for i in segments:
        if i[0] == i[1]:
            source_file.write(f'  if (codepoint == {hex(i[0])})\n')
            source_file.write(f'    return {offset};\n')
        else:
            source_file.write(f'  if ({hex(i[0])} <= codepoint && codepoint <= {hex(i[1])})\n')
            source_file.write(f'    return codepoint - {hex(i[0])} + {offset};\n')
        offset += i[1] - i[0] + 1

    source_file.write(f'  return {notdef_char_index};\n')
    source_file.write(f'}}\n')
    source_file.write('\n')


def gen_atlas(src_file, image):

    VALS_PER_LINE = 16

    img = Image.open(image)

    src_file.write(f'static const glcvs_embeded_font_atlas {ATLAS_NAME} = {{\n'); #}
    src_file.write(f'  .width = {img.width},\n');
    src_file.write(f'  .height = {img.height},\n');
    src_file.write( '  .data = {\n'); #}

    data = tuple(img.getdata(3))
    for idx, i in enumerate(data): # Alpha
        if idx % VALS_PER_LINE == 0:
            if idx:
                src_file.write('\n')
            src_file.write('    ')

        src_file.write('0x' + hex(i)[2:].rjust(2, '0') + ', ')
    
    src_file.write('\n  }\n')
    src_file.write('};\n')
    src_file.write('\n')

# --- Utils

def parse_line(line : str):
    """Parse one line of font defenition file"""

    name, other = line.split(maxsplit=1)

    kv_pairs = [ i.split('=', 1) for i in shlex.split(other) ]
    props = { key: value for key, value in kv_pairs }
    return name, props

# --- Main program

if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == '--help':
        print(__doc__)
    elif len(sys.argv) != 5:
        print('Consult --help on how to use this thing.')
        exit(-1)
    else:
        zf = zipfile.ZipFile(sys.argv[1])

        data_file_name = [ i for i in zf.namelist() if i.endswith('.txt') ]
        if len(data_file_name) == 0:
            raise ValueError('Could not find font defenition inside given archive')
        elif len(data_file_name) > 1:
            raise ValueError('Found multiple font defenitions (or some other .txt files) in given archive')
       
        # FIXME: parse font defenition to get that
        image_file_name = data_file_name[0][:-4] + '.png'
        
        header = open(sys.argv[2], 'w')
        source = open(sys.argv[3], 'w')
        gen_defenitions(
            header, source,
            zf.open(data_file_name[0]),
            zf.open(image_file_name),
            sys.argv[4]
        )
        header.close()
        source.close()


